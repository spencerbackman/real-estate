"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = __importDefault(require("lodash"));
var node_expat_1 = __importDefault(require("node-expat"));
var MetadataParser = /** @class */ (function () {
    function MetadataParser(parserEncoding) {
        if (parserEncoding === void 0) { parserEncoding = 'UTF-8'; }
        this.schemas = [];
        this.currentEntityType = { name: '', path: '', primaryKey: '', properties: [] };
        this.currentProperty = {
            annotations: [],
            maxLength: null,
            name: '',
            nullable: null,
            path: '',
            precision: null,
            scale: null,
            type: '',
        };
        this.currentEnumType = { name: '', enums: [], isFlags: false, path: '', underlyingType: '' };
        this.currentMember = { annotations: [], name: '', path: '', value: '' };
        this.currentType = '';
        this.parser = new node_expat_1.default.Parser(parserEncoding);
    }
    MetadataParser.prototype.parse = function (rawData) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.parser.on('startElement', _this.tagStart.bind(_this));
            _this.parser.on('endElement', _this.tagEnd.bind(_this));
            _this.parser.on('error', function (err) {
                reject(err);
            });
            _this.parser.write(rawData);
            resolve(_this.schemas);
            _this.parser.end();
        });
    };
    MetadataParser.prototype.toBool = function (value) {
        if (typeof value === 'string') {
            return ['true', 'yes', 'y', 't', '1'].includes(value.toLowerCase());
        }
        else if (typeof value === 'boolean') {
            return value;
        }
        return false;
    };
    MetadataParser.prototype.tagStart = function (name, args) {
        var lastSchema = this.getLastSchema();
        switch (name) {
            case 'Schema':
                this.schemas.push({
                    entityTypes: [],
                    enumTypes: [],
                    name: args.Namespace,
                    path: args.Namespace,
                });
                break;
            case 'EntitySet':
                this.currentEntityType = {
                    name: args.Name,
                    path: lastSchema ? lastSchema.path + "." + args.Name : args.Name,
                    properties: [],
                    type: args.EntityType,
                };
                break;
            case 'ComplexType':
            case 'EntityType':
                this.currentEntityType = {
                    name: args.Name,
                    path: lastSchema ? lastSchema.path + "." + args.Name : args.Name,
                    properties: [],
                };
                break;
            case 'PropertyRef':
                this.currentEntityType.primaryKey = args.Name;
                break;
            case 'NavigationPropertyBinding':
                this.currentProperty = {
                    annotations: [],
                    maxLength: null,
                    name: args.Path,
                    nullable: args.Nullable,
                    path: this.currentEntityType.path + "." + args.Path,
                    precision: null,
                    scale: null,
                    type: args.Target,
                };
                this.currentType = 'Property';
                break;
            case 'NavigationProperty':
            case 'Property':
                this.currentProperty = {
                    annotations: [],
                    maxLength: lodash_1.default.get(args, 'MaxLength', null),
                    name: args.Name,
                    nullable: args.Nullable,
                    path: lastSchema ? this.currentEntityType.path + "." + args.Name : args.Name,
                    precision: lodash_1.default.get(args, 'Precision', null),
                    scale: lodash_1.default.get(args, 'Scale', null),
                    type: lodash_1.default.get(args, 'Type', 'String'),
                };
                this.currentType = 'Property';
                break;
            case 'EnumType':
                this.currentEnumType = {
                    enums: [],
                    isFlags: this.toBool(lodash_1.default.get(args, 'IsFlags', false)),
                    name: args.Name,
                    path: lastSchema ? lastSchema.path + "." + args.Name : args.Name,
                    underlyingType: args.UnderlyingType,
                };
            case 'Member':
                this.currentType = 'Member';
                this.currentMember = {
                    annotations: [],
                    name: args.Name,
                    path: lastSchema ? this.currentEnumType.path + "." + args.Name : args.Name,
                    value: args.Value,
                };
                break;
            case 'Annotation':
                var current = this.getCurrentType();
                if (current) {
                    current.annotations.push({
                        term: args.Term,
                        value: lodash_1.default.get(args, 'String', null),
                    });
                }
                break;
        }
    };
    MetadataParser.prototype.getLastSchema = function () {
        return this.schemas[this.schemas.length - 1];
    };
    MetadataParser.prototype.getCurrentType = function () {
        switch (this.currentType) {
            case 'Property':
                this.currentType = '';
                return this.currentProperty;
            case 'Member':
                this.currentType = '';
                return this.currentMember;
        }
    };
    MetadataParser.prototype.tagEnd = function (name) {
        var schema = this.getLastSchema();
        switch (name) {
            case 'EntitySet':
            case 'ComplexType':
            case 'EntityType':
                if (schema) {
                    schema.entityTypes.push(this.currentEntityType);
                }
                break;
            case 'NavigationPropertyBinding':
            case 'NavigationProperty':
            case 'Property':
                this.currentEntityType.properties.push(this.currentProperty);
                break;
            case 'EnumType':
                if (schema) {
                    schema.enumTypes.push(this.currentEnumType);
                }
                break;
            case 'Member':
                this.currentEnumType.enums.push(this.currentMember);
                break;
        }
    };
    return MetadataParser;
}());
exports.MetadataParser = MetadataParser;
//# sourceMappingURL=metadata-parser.js.map